/*
 * Copyright (c) 2020-2021. Bohdan Kolvakh
 * This file is part of MyAccounts.
 *
 * MyAccounts is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MyAccounts is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

package com.acmpo6ou.myaccounts.utils

import com.acmpo6ou.myaccounts.*
import com.acmpo6ou.myaccounts.core.utils.DatabaseUtils
import com.acmpo6ou.myaccounts.database.databases_list.Database
import com.acmpo6ou.myaccounts.database.databases_list.DbMap
import com.macasaet.fernet.StringValidator
import com.macasaet.fernet.Token
import com.macasaet.fernet.Validator
import com.nhaarman.mockitokotlin2.doAnswer
import com.nhaarman.mockitokotlin2.doReturn
import com.nhaarman.mockitokotlin2.spy
import com.nhaarman.mockitokotlin2.whenever
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import java.io.File
import java.io.FileNotFoundException
import java.time.Duration
import java.time.Instant
import java.time.temporal.TemporalAmount

open class DbUtils(override val app: MyApp) : DatabaseUtils

class DatabaseUtilsTests : ModelTest() {
    private lateinit var databaseUtils: DatabaseUtils
    lateinit var spyUtils: DatabaseUtils

    lateinit var myApp: MyApp
    val database = Database("test", "123", salt, mutableMapOf())

    @Before
    fun setup() {
        myApp = MyApp()
        app = spy(myApp) {
            on { ACCOUNTS_DIR } doReturn accountsDir
            on { SRC_DIR } doReturn SRC_DIR
        }

        databaseUtils = DbUtils(app)
        spyUtils = spy(databaseUtils)
    }

    /**
     * Encrypts given map using [password] and [salt].
     *
     * @param[map] database map to encrypt.
     * @return encrypted json string of database map.
     */
    private fun encryptStr(map: DbMap): String {
        val key = deriveKey(password, salt)
        val data = dumps(map)
        val token = Token.generate(key, data)
        return token.serialise()
    }

    /**
     * This method decrypts given string.
     *
     * @param[string] string to decrypt.
     * @param[password] password for decryption.
     * @param[salt] salt for decryption.
     * @return decrypted string.
     */
    private fun decryptStr(string: String, password: String, salt: ByteArray): String {
        val key = deriveKey(password, salt)
        val validator: Validator<String> = object : StringValidator {
            // this checks whether our encrypted json string is expired or not
            // in our app we don't care about expiration so we return Instant.MAX.epochSecond
            override fun getTimeToLive(): TemporalAmount =
                Duration.ofSeconds(Instant.MAX.epochSecond)
        }
        val token = Token.fromString(string)
        return token.validateAndDecrypt(key, validator)
    }

    @Test
    fun `openDatabase should return Database instance with non empty data property`() {
        // copy `main` database to the fake file system so that we can open it later
        copyDatabase("main")

        // create corresponding Database instance
        val db = Database("main", password, salt)

        val actualDatabase = openDatabase(db)
        val expectedDatabase = Database("main", password, salt, databaseMap)

        assertEquals(expectedDatabase, actualDatabase)
    }

    @Test
    fun `decryptDatabase should return decrypted and deserialized map given string`() {
        // encrypt database
        val expectedMap = databaseMap
        val encryptedJson = encryptStr(expectedMap)

        val map = decryptDatabase(encryptedJson, password, salt)
        assertEquals(
            "Incorrect decryption! decryptDatabase method",
            expectedMap, map
        )
    }

    @Test
    fun `decryptDatabase should cache generated by deriveKey key`() {
        // create fresh application instance
        app = MyApp()

        // encrypt database
        val expectedMap = databaseMap
        val encryptedJson = encryptStr(expectedMap)

        decryptDatabase(encryptedJson, password, salt)

        // check that key was cached
        val expectedKey = deriveKey(password, salt)
        assertEquals(app.keyCache[password], expectedKey)
    }

    @Test
    fun `encryptDatabase should cache generated by deriveKey key`() {
        // create fresh application instance
        app = MyApp()

        val database = Database(faker.str(), password, salt, databaseMap)
        encryptDatabase(database)

        // check that key was cached
        val expectedKey = deriveKey(password, salt)
        assertEquals(app.keyCache[password], expectedKey)
    }

    @Test
    fun `encryptDatabase should return encrypted json string from Database`() {
        val database = Database(faker.str(), faker.str(), salt, databaseMap)

        // get encrypted json string
        val jsonStr = encryptDatabase(database)

        // here we decrypt the json string using salt and password we defined earlier
        // to check if it were encrypted correctly
        val data = decryptStr(jsonStr, database.password!!, database.salt!!)

        assertEquals(
            "encryptDatabase has returned incorrectly encrypted json string!",
            jsonDatabase, data
        )
    }

    @Test
    fun `loads should return empty map when passed empty string`() {
        val loadMap = loads("")
        assertTrue(loadMap.isEmpty())
    }

    @Test
    fun `loads should return non empty map when passed non empty string`() {
        val map = loads(jsonDatabase)
        val expectedMap = databaseMap
        assertEquals(expectedMap, map)
    }

    @Test
    fun `dumps should return empty string when passed empty map`() {
        val dumpStr = dumps(mutableMapOf())
        assertTrue(dumpStr.isEmpty())
    }

    @Test
    fun `dumps should return serialized string when passed non empty map`() {
        // create database map with account that we will serialize
        val databaseMap = databaseMap

        // serialize database and check resulting json string
        val dumpStr = dumps(databaseMap)
        val expectedStr = jsonDatabase

        assertEquals(expectedStr, dumpStr)
    }

    @Test
    fun `createDatabase should create db file given Database instance`() {
        val database = Database("main", "123", salt, databaseMap)
        createDatabase(database)

        // this is a .db file that createDatabase should create for us
        val actualDb = File("$SRC_DIR/main.db").readBytes()

        // here we decrypt data saved to .db file to check that it was encrypted correctly
        val data = decryptStr(String(actualDb), "123", salt)
        assertEquals(
            "createDatabase creates incorrectly encrypted database!",
            jsonDatabase, data
        )
    }

    @Test
    fun `createDatabase should create salt file given Database instance`() {
        val database = Database("main", "123", salt)
        createDatabase(database)

        // this is a salt file that createDatabase should create for us
        val actualBin = File("$SRC_DIR/main.bin").readBytes()

        assertEquals(
            "createDatabase created incorrect salt file!",
            String(salt), String(actualBin)
        )
    }

    @Test
    fun `deleteDatabase should remove db and bin files from disk`() {
        // create empty database so that we can delete it using deleteDatabase
        val database = Database("main", "123", salt)
        createDatabase(database)

        deleteDatabase("main")

        // files that should be deleted
        val binFile = File("$SRC_DIR/main.bin")
        val dbFile = File("$SRC_DIR/main.db")

        assertFalse(
            "deleteDatabase didn't delete .bin file",
            binFile.exists()
        )
        assertFalse(
            "deleteDatabase didn't delete .db file",
            dbFile.exists()
        )
    }

    @Test
    fun `isDatabaseSaved should return false`() {
        // here database on disk is different then in-memory database
        val diskDatabase = Database("test", "123", salt, databaseMap)
        doReturn(diskDatabase).`when`(spyUtils).openDatabase(database)

        assertFalse(spyUtils.isDatabaseSaved(database))
    }

    @Test
    fun `isDatabaseSaved should return true`() {
        // here database on disk is exactly the same as database in memory
        doReturn(database).`when`(spyUtils).openDatabase(database)
        assertTrue(spyUtils.isDatabaseSaved(database))
    }

    @Test
    fun `isDatabaseSaved should return false when FileNotFoundException occurred`() {
        doAnswer {
            throw FileNotFoundException("")
        }.whenever(spyUtils).openDatabase(database)
        assertFalse(spyUtils.isDatabaseSaved(database))
    }
}
